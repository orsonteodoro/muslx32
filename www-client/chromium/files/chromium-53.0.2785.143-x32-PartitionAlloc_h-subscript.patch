--- chromium-53.0.2785.143/third_party/WebKit/Source/wtf/allocator/PartitionAlloc.h.orig	2016-11-16 09:33:50.571311774 -0800
+++ chromium-53.0.2785.143/third_party/WebKit/Source/wtf/allocator/PartitionAlloc.h	2016-11-16 09:35:34.095236620 -0800
@@ -719,12 +719,12 @@ ALWAYS_INLINE void partitionFree(void* p
 
 ALWAYS_INLINE PartitionBucket* partitionGenericSizeToBucket(PartitionRootGeneric* root, size_t size)
 {
-    size_t order = kBitsPerSizet - countLeadingZerosSizet(size);
+    size_t order = static_cast<size_t>(kBitsPerSizet - countLeadingZerosSizet(size));
     // The order index is simply the next few bits after the most significant bit.
-    size_t orderIndex = (size >> root->orderIndexShifts[order]) & (kGenericNumBucketsPerOrder - 1);
+    size_t orderIndex = (size >> root->orderIndexShifts[static_cast<size_t>(order)]) & (kGenericNumBucketsPerOrder - 1);
     // And if the remaining bits are non-zero we must bump the bucket up.
-    size_t subOrderIndex = size & root->orderSubIndexMasks[order];
-    PartitionBucket* bucket = root->bucketLookups[(order << kGenericNumBucketsPerOrderBits) + orderIndex + !!subOrderIndex];
+    size_t subOrderIndex = size & root->orderSubIndexMasks[static_cast<size_t>(order)];
+    PartitionBucket* bucket = root->bucketLookups[static_cast<size_t>((order << kGenericNumBucketsPerOrderBits) + orderIndex + !!subOrderIndex)];
     ASSERT(!bucket->slotSize || bucket->slotSize >= size);
     ASSERT(!(bucket->slotSize % kGenericSmallestBucket));
     return bucket;
