diff -ur firefox-45.2.0esr.orig/js/src/jit/JitFrames.cpp firefox-45.2.0esr/js/src/jit/JitFrames.cpp
--- firefox-45.2.0esr.orig/js/src/jit/JitFrames.cpp	2016-05-12 10:09:59.000000000 -0700
+++ firefox-45.2.0esr/js/src/jit/JitFrames.cpp	2016-09-06 17:20:53.670963455 -0700
@@ -2056,7 +2056,11 @@
 void
 SnapshotIterator::writeAllocationValuePayload(const RValueAllocation& alloc, Value v)
 {
+#if defined(__x86_64__) && defined(__ILP32__)
+    uint64_t payload = *v.payloadUIntPtr();
+#else
     uintptr_t payload = *v.payloadUIntPtr();
+#endif
 #if defined(JS_PUNBOX64)
     // Do not write back the tag, as this will trigger an assertion when we will
     // reconstruct the JS Value while marking again or when bailing out.
diff -ur firefox-45.2.0esr.orig/js/src/jit/shared/Assembler-shared.h firefox-45.2.0esr/js/src/jit/shared/Assembler-shared.h
--- firefox-45.2.0esr.orig/js/src/jit/shared/Assembler-shared.h	2016-09-06 15:30:46.949745747 -0700
+++ firefox-45.2.0esr/js/src/jit/shared/Assembler-shared.h	2016-09-06 21:37:57.650471713 -0700
@@ -119,10 +119,17 @@
 // Pointer-sized integer to be embedded as an immediate in an instruction.
 struct ImmWord
 {
+#if defined(__x86_64__) && defined(__ILP32__)
+    uint64_t value;
+
+    explicit ImmWord(uint64_t value) : value(value)
+    { }
+#else
     uintptr_t value;
 
     explicit ImmWord(uintptr_t value) : value(value)
     { }
+#endif
 };
 
 // Used for 64-bit immediates which do not require relocation.
diff -ur firefox-45.2.0esr.orig/js/src/jit/x64/Assembler-x64.h firefox-45.2.0esr/js/src/jit/x64/Assembler-x64.h
--- firefox-45.2.0esr.orig/js/src/jit/x64/Assembler-x64.h	2016-05-12 10:09:59.000000000 -0700
+++ firefox-45.2.0esr/js/src/jit/x64/Assembler-x64.h	2016-09-06 15:54:41.260793012 -0700
@@ -347,9 +347,9 @@
         if (word.value <= UINT32_MAX) {
             // movl has a 32-bit unsigned (effectively) immediate field.
             masm.movl_i32r((uint32_t)word.value, dest.encoding());
-        } else if ((intptr_t)word.value >= INT32_MIN && (intptr_t)word.value <= INT32_MAX) {
+        } else if ((int64_t)word.value >= INT32_MIN && (int64_t)word.value <= INT32_MAX) {
             // movq has a 32-bit signed immediate field.
-            masm.movq_i32r((int32_t)(intptr_t)word.value, dest.encoding());
+            masm.movq_i32r((int32_t)(int64_t)word.value, dest.encoding());
         } else {
             // Otherwise use movabs.
             masm.movq_i64r(word.value, dest.encoding());
diff -ur firefox-45.2.0esr.orig/js/src/jit/x64/MacroAssembler-x64-inl.h firefox-45.2.0esr/js/src/jit/x64/MacroAssembler-x64-inl.h
--- firefox-45.2.0esr.orig/js/src/jit/x64/MacroAssembler-x64-inl.h	2016-05-12 10:09:59.000000000 -0700
+++ firefox-45.2.0esr/js/src/jit/x64/MacroAssembler-x64-inl.h	2016-09-06 16:01:28.534806432 -0700
@@ -32,7 +32,7 @@
 void
 MacroAssembler::and64(Imm64 imm, Register64 dest)
 {
-    movq(ImmWord(uintptr_t(imm.value)), ScratchReg);
+    movq(ImmWord(uint64_t(imm.value)), ScratchReg);
     andq(ScratchReg, dest.reg);
 }
 
diff -ur firefox-45.2.0esr.orig/js/src/jit/x64/MacroAssembler-x64.cpp firefox-45.2.0esr/js/src/jit/x64/MacroAssembler-x64.cpp
--- firefox-45.2.0esr.orig/js/src/jit/x64/MacroAssembler-x64.cpp	2016-05-12 10:09:59.000000000 -0700
+++ firefox-45.2.0esr/js/src/jit/x64/MacroAssembler-x64.cpp	2016-09-06 21:37:23.652470592 -0700
@@ -286,7 +286,7 @@
     Value start = ObjectValue(*reinterpret_cast<JSObject*>(nursery.start()));
 
     ScratchRegisterScope scratch(asMasm());
-    movePtr(ImmWord(-ptrdiff_t(start.asRawBits())), scratch);
+    movePtr(ImmWord(-int64_t(start.asRawBits())), scratch);
     addPtr(value.valueReg(), scratch);
     branchPtr(cond == Assembler::Equal ? Assembler::Below : Assembler::AboveOrEqual,
               scratch, Imm32(nursery.nurserySize()), label);
diff -ur firefox-45.2.0esr.orig/js/src/jit/x64/MacroAssembler-x64.h firefox-45.2.0esr/js/src/jit/x64/MacroAssembler-x64.h
--- firefox-45.2.0esr.orig/js/src/jit/x64/MacroAssembler-x64.h	2016-05-12 10:09:59.000000000 -0700
+++ firefox-45.2.0esr/js/src/jit/x64/MacroAssembler-x64.h	2016-09-06 16:04:34.460812559 -0700
@@ -17,11 +17,11 @@
 struct ImmShiftedTag : public ImmWord
 {
     explicit ImmShiftedTag(JSValueShiftedTag shtag)
-      : ImmWord((uintptr_t)shtag)
+      : ImmWord((uint64_t)shtag)
     { }
 
     explicit ImmShiftedTag(JSValueType type)
-      : ImmWord(uintptr_t(JSValueShiftedTag(JSVAL_TYPE_TO_SHIFTED_TAG(type))))
+      : ImmWord(uint64_t(JSValueShiftedTag(JSVAL_TYPE_TO_SHIFTED_TAG(type))))
     { }
 };
 
@@ -461,7 +461,7 @@
     void cmpPtr(Register lhs, const ImmWord rhs) {
         ScratchRegisterScope scratch(asMasm());
         MOZ_ASSERT(lhs != scratch);
-        if (intptr_t(rhs.value) <= INT32_MAX && intptr_t(rhs.value) >= INT32_MIN) {
+        if (int64_t(rhs.value) <= INT32_MAX && int64_t(rhs.value) >= INT32_MIN) {
             cmpPtr(lhs, Imm32(int32_t(rhs.value)));
         } else {
             movePtr(rhs, scratch);
@@ -487,7 +487,7 @@
         cmpPtr(lhs, scratch);
     }
     void cmpPtr(const Operand& lhs, const ImmWord rhs) {
-        if ((intptr_t)rhs.value <= INT32_MAX && (intptr_t)rhs.value >= INT32_MIN) {
+        if ((int64_t)rhs.value <= INT32_MAX && (int64_t)rhs.value >= INT32_MIN) {
             cmpPtr(lhs, Imm32((int32_t)rhs.value));
         } else {
             ScratchRegisterScope scratch(asMasm());
@@ -558,7 +558,7 @@
     void addPtr(ImmWord imm, Register dest) {
         ScratchRegisterScope scratch(asMasm());
         MOZ_ASSERT(dest != scratch);
-        if ((intptr_t)imm.value <= INT32_MAX && (intptr_t)imm.value >= INT32_MIN) {
+        if ((int64_t)imm.value <= INT32_MAX && (int64_t)imm.value >= INT32_MIN) {
             addq(Imm32((int32_t)imm.value), dest);
         } else {
             mov(imm, scratch);
@@ -590,7 +590,7 @@
         lea(Operand(src, src, TimesTwo), dest);
     }
     void mul64(Imm64 imm, const Register64& dest) {
-        movq(ImmWord(uintptr_t(imm.value)), ScratchReg);
+        movq(ImmWord(uint64_t(imm.value)), ScratchReg);
         imulq(ScratchReg, dest.reg);
     }
 
@@ -789,7 +789,7 @@
 
     template <typename T>
     void storePtr(ImmWord imm, T address) {
-        if ((intptr_t)imm.value <= INT32_MAX && (intptr_t)imm.value >= INT32_MIN) {
+        if ((int64_t)imm.value <= INT32_MAX && (int64_t)imm.value >= INT32_MIN) {
             movq(Imm32((int32_t)imm.value), Operand(address));
         } else {
             ScratchRegisterScope scratch(asMasm());
diff -ur firefox-45.2.0esr.orig/js/src/jit/x86-shared/Assembler-x86-shared.cpp firefox-45.2.0esr/js/src/jit/x86-shared/Assembler-x86-shared.cpp
--- firefox-45.2.0esr.orig/js/src/jit/x86-shared/Assembler-x86-shared.cpp	2016-05-12 10:09:59.000000000 -0700
+++ firefox-45.2.0esr/js/src/jit/x86-shared/Assembler-x86-shared.cpp	2016-09-06 15:50:09.722784064 -0700
@@ -56,7 +56,7 @@
 #ifdef JS_PUNBOX64
         // All pointers on x64 will have the top bits cleared. If those bits
         // are not cleared, this must be a Value.
-        uintptr_t* word = reinterpret_cast<uintptr_t*>(ptr);
+        uint64_t* word = reinterpret_cast<uint64_t*>(ptr);
         if (*word >> JSVAL_TAG_SHIFT) {
             jsval_layout layout;
             layout.asBits = *word;
diff -ur firefox-45.2.0esr.orig/js/src/vm/ObjectGroup.cpp firefox-45.2.0esr/js/src/vm/ObjectGroup.cpp
--- firefox-45.2.0esr.orig/js/src/vm/ObjectGroup.cpp	2016-05-12 10:10:03.000000000 -0700
+++ firefox-45.2.0esr/js/src/vm/ObjectGroup.cpp	2016-09-06 19:48:13.111254736 -0700
@@ -267,6 +267,7 @@
 {
     MOZ_ASSERT(cx->compartment() == compartment());
 
+    printf("orson touch 1");
     RootedObject self(cx, this);
 
     /*
@@ -275,26 +276,42 @@
      * the old or new types.
      */
     MOZ_ASSERT(self->isSingleton());
+    printf("orson touch 2");
 
     // Windows may not appear on prototype chains.
     MOZ_ASSERT_IF(proto.isObject(), !IsWindow(proto.toObject()));
+    printf("orson touch 3");
 
     if (proto.isObject() && !proto.toObject()->setDelegate(cx))
         return false;
+    printf("orson touch 4");
 
     // Force type instantiation when splicing lazy group.
     RootedObjectGroup group(cx, self->getGroup(cx));
     if (!group)
         return false;
+    printf("orson touch 5");
     RootedObjectGroup protoGroup(cx, nullptr);
+    printf("orson touch 6");
     if (proto.isObject()) {
         protoGroup = proto.toObject()->getGroup(cx);
         if (!protoGroup)
             return false;
     }
+    printf("orson touch 7");
+
+    printf("%p", uintptr_t(clasp));
+
+    if (uintptr_t(clasp) == uintptr_t(0x4d))
+    {
+       printf("error here orson");
+       exit(-1);
+    }
 
     group->setClasp(clasp);
+    printf("orson touch 8");
     group->setProto(proto);
+    printf("orson touch 9");
     return true;
 }
 
diff -ur firefox-45.2.0esr.orig/js/src/vm/ObjectGroup.h firefox-45.2.0esr/js/src/vm/ObjectGroup.h
--- firefox-45.2.0esr.orig/js/src/vm/ObjectGroup.h	2016-05-12 10:10:03.000000000 -0700
+++ firefox-45.2.0esr/js/src/vm/ObjectGroup.h	2016-09-06 21:21:41.655439551 -0700
@@ -91,7 +91,10 @@
   public:
 
     const Class* clasp() const {
-        return clasp_;
+        if (uintptr_t(this) == uintptr_t(0x4d))
+		return nullptr;
+	else
+	        return clasp_;
     }
 
     void setClasp(const Class* clasp) {
diff -ur firefox-45.2.0esr.orig/js/src/vm/UnboxedObject.cpp firefox-45.2.0esr/js/src/vm/UnboxedObject.cpp
--- firefox-45.2.0esr.orig/js/src/vm/UnboxedObject.cpp	2016-05-12 10:10:03.000000000 -0700
+++ firefox-45.2.0esr/js/src/vm/UnboxedObject.cpp	2016-09-06 19:37:47.785234130 -0700
@@ -1901,6 +1901,8 @@
 {
     bool isArray = !templateShape;
 
+    printf("orson touch 1a");
+
     // Unboxed arrays are nightly only for now. The getenv() call will be
     // removed when they are on by default. See bug 1153266.
     if (isArray) {
@@ -2050,6 +2052,11 @@
     }
 
     group->setClasp(clasp);
+    if (uintptr_t(clasp) == uintptr_t(0x4d))
+    {
+       printf("error here orson");
+       exit(-1);
+    }
     group->setUnboxedLayout(layout.release());
 
     size_t valueCursor = 0;
