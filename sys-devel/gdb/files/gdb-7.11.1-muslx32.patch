diff -ur gdb-7.11.1.orig/gdb/amd64-linux-nat.c gdb-7.11.1/gdb/amd64-linux-nat.c
--- gdb-7.11.1.orig/gdb/amd64-linux-nat.c	2016-07-10 18:17:10.526948236 -0700
+++ gdb-7.11.1/gdb/amd64-linux-nat.c	2016-07-10 18:32:50.650918133 -0700
@@ -49,6 +49,28 @@
    little-endian we get away with that.  */
 
 /* From <sys/reg.h> on GNU/Linux i386.  */
+#if __ILP32__
+static int amd64_linux_gregset32_reg_offset[] =
+{
+  RAX * 4, RCX * 4,		/* %eax, %ecx */
+  RDX * 4, RBX * 4,		/* %edx, %ebx */
+  RSP * 4, RBP * 4,		/* %esp, %ebp */
+  RSI * 4, RDI * 4,		/* %esi, %edi */
+  RIP * 4, EFLAGS * 4,		/* %eip, %eflags */
+  CS * 4, SS * 4,		/* %cs, %ss */
+  DS * 4, ES * 4,		/* %ds, %es */
+  FS * 4, GS * 4,		/* %fs, %gs */
+  -1, -1, -1, -1, -1, -1, -1, -1,
+  -1, -1, -1, -1, -1, -1, -1, -1,
+  -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  -1, -1, -1, -1, -1, -1, -1, -1,
+  -1, -1, -1, -1,		  /* MPX registers BND0 ... BND3.  */
+  -1, -1,			  /* MPX registers BNDCFGU, BNDSTATUS.  */
+  -1, -1, -1, -1, -1, -1, -1, -1, /* k0 ... k7 (AVX512)  */
+  -1, -1, -1, -1, -1, -1, -1, -1, /* zmm0 ... zmm7 (AVX512)  */
+  ORIG_RAX * 4			  /* "orig_eax"  */
+};
+#else
 static int amd64_linux_gregset32_reg_offset[] =
 {
   RAX * 8, RCX * 8,		/* %eax, %ecx */
@@ -69,6 +91,7 @@
   -1, -1, -1, -1, -1, -1, -1, -1, /* zmm0 ... zmm7 (AVX512)  */
   ORIG_RAX * 8			  /* "orig_eax"  */
 };
+#endif
 
 
 /* Transfering the general-purpose registers between GDB, inferiors
diff -ur gdb-7.11.1.orig/gdb/gdbserver/linux-x86-low.c gdb-7.11.1/gdb/gdbserver/linux-x86-low.c
--- gdb-7.11.1.orig/gdb/gdbserver/linux-x86-low.c	2016-07-10 18:17:10.528948236 -0700
+++ gdb-7.11.1/gdb/gdbserver/linux-x86-low.c	2016-07-10 18:48:41.981887670 -0700
@@ -155,6 +155,15 @@
 /* Mapping between the general-purpose registers in `struct user'
    format and GDB's register array layout.
    Note that the transfer layout uses 64-bit regs.  */
+#ifdef __ILP32__
+static /*const*/ int i386_regmap[] = 
+{
+  RAX * 4, RCX * 4, RDX * 4, RBX * 4,
+  RSP * 4, RBP * 4, RSI * 4, RDI * 4,
+  RIP * 4, EFLAGS * 4, CS * 4, SS * 4,
+  DS * 4, ES * 4, FS * 4, GS * 4
+};
+#else
 static /*const*/ int i386_regmap[] = 
 {
   RAX * 8, RCX * 8, RDX * 8, RBX * 8,
@@ -162,13 +171,46 @@
   RIP * 8, EFLAGS * 8, CS * 8, SS * 8,
   DS * 8, ES * 8, FS * 8, GS * 8
 };
+#endif
 
 #define I386_NUM_REGS (sizeof (i386_regmap) / sizeof (i386_regmap[0]))
 
 /* So code below doesn't have to care, i386 or amd64.  */
 #define ORIG_EAX ORIG_RAX
+#ifdef __ILP32__
+#define REGSIZE 4
+#else
 #define REGSIZE 8
+#endif
 
+#ifdef __ILP32__
+static const int x86_64_regmap[] =
+{
+  RAX * 4, RBX * 4, RCX * 4, RDX * 4,
+  RSI * 4, RDI * 4, RBP * 4, RSP * 4,
+  R8 * 4, R9 * 4, R10 * 4, R11 * 4,
+  R12 * 4, R13 * 4, R14 * 4, R15 * 4,
+  RIP * 4, EFLAGS * 4, CS * 4, SS * 4,
+  DS * 4, ES * 4, FS * 4, GS * 4,
+  -1, -1, -1, -1, -1, -1, -1, -1,
+  -1, -1, -1, -1, -1, -1, -1, -1,
+  -1, -1, -1, -1, -1, -1, -1, -1,
+  -1,
+  -1, -1, -1, -1, -1, -1, -1, -1,
+  ORIG_RAX * 4,
+  -1, -1, -1, -1,			/* MPX registers BND0 ... BND3.  */
+  -1, -1,				/* MPX registers BNDCFGU, BNDSTATUS.  */
+  -1, -1, -1, -1, -1, -1, -1, -1,       /* xmm16 ... xmm31 (AVX512)  */
+  -1, -1, -1, -1, -1, -1, -1, -1,
+  -1, -1, -1, -1, -1, -1, -1, -1,       /* ymm16 ... ymm31 (AVX512)  */
+  -1, -1, -1, -1, -1, -1, -1, -1,
+  -1, -1, -1, -1, -1, -1, -1, -1,       /* k0 ... k7 (AVX512)  */
+  -1, -1, -1, -1, -1, -1, -1, -1,       /* zmm0 ... zmm31 (AVX512)  */
+  -1, -1, -1, -1, -1, -1, -1, -1,
+  -1, -1, -1, -1, -1, -1, -1, -1,
+  -1, -1, -1, -1, -1, -1, -1, -1
+};
+#else
 static const int x86_64_regmap[] =
 {
   RAX * 8, RBX * 8, RCX * 8, RDX * 8,
@@ -195,6 +237,7 @@
   -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1
 };
+#endif
 
 #define X86_64_NUM_REGS (sizeof (x86_64_regmap) / sizeof (x86_64_regmap[0]))
 #define X86_64_USER_REGS (GS + 1)
@@ -361,8 +404,12 @@
 
   /* 32-bit inferior registers need to be zero-extended.
      Callers would read uninitialized memory otherwise.  */
+#if __ILP32__
+  memset (buf, 0x00, X86_64_USER_REGS * 4);
+#else
   memset (buf, 0x00, X86_64_USER_REGS * 8);
 #endif
+#endif
 
   for (i = 0; i < I386_NUM_REGS; i++)
     collect_register (regcache, i, ((char *) buf) + i386_regmap[i]);
@@ -1973,7 +2020,11 @@
   buf[i++] = 0x64;
   buf[i++] = 0x24;
   /* This only handles adjustments up to 16, but we don't expect any more.  */
+#ifdef __ILP32__
+  buf[i++] = n * 4;
+#else
   buf[i++] = n * 8;
+#endif
   append_insns (&buildaddr, i, buf);
   current_insn_ptr = buildaddr;
 }
@@ -2589,7 +2640,11 @@
   buf[i++] = 0x8d; /* lea $<n>(%esp),%esp */
   buf[i++] = 0x64;
   buf[i++] = 0x24;
+#ifdef __ILP32__
+  buf[i++] = n * 4;
+#else
   buf[i++] = n * 8;
+#endif
   append_insns (&buildaddr, i, buf);
   current_insn_ptr = buildaddr;
 }
diff -ur gdb-7.11.1.orig/gdb/nat/linux-ptrace.c gdb-7.11.1/gdb/nat/linux-ptrace.c
--- gdb-7.11.1.orig/gdb/nat/linux-ptrace.c	2016-02-09 19:19:39.000000000 -0800
+++ gdb-7.11.1/gdb/nat/linux-ptrace.c	2016-07-10 18:21:04.832940734 -0700
@@ -193,8 +193,13 @@
   l = ptrace (PTRACE_PEEKUSER, child, (PTRACE_TYPE_ARG3) (uintptr_t) (EIP * 4),
 	      (PTRACE_TYPE_ARG4) NULL);
 #elif defined __x86_64__
+#if defined __ILP32__
+  l = ptrace (PTRACE_PEEKUSER, child, (PTRACE_TYPE_ARG3) (uintptr_t) (RIP * 4),
+	      (PTRACE_TYPE_ARG4) NULL);
+#else
   l = ptrace (PTRACE_PEEKUSER, child, (PTRACE_TYPE_ARG3) (uintptr_t) (RIP * 8),
 	      (PTRACE_TYPE_ARG4) NULL);
+#endif
 #else
 # error "!__i386__ && !__x86_64__"
 #endif
