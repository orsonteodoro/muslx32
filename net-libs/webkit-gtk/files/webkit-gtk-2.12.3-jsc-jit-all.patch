notes:
this patch is mostly based on attachment 169623 (20121123) or on attachment 169623 (20121019)
some parts were based on patches in bug 100450 on webkit-bugzilla
it is an incomplete patch because of the missing JITStubs.*
MacroAssemblerX86Common.cpp has assembly code that may need to be patched for x32 but didn't get applied in this patch

missing:
JITStubs.h
JITStubs.cpp

commented out:
void store32(RegisterID src, void* addres

#from patches in bug 100450
MacroAssemblerX86_64.h: const int immediateBytes = sizeof(void*)
MacroAssemblerX86_64.h: X86Assembler::revertJumpTo_movl_i32r
DFGNode.h: #if OS(DARWIN) || (CPU(X86_64) && !CPU(X32))
MacroAssemblerX86Common.h: void push(Address address)

my modifications:
MacroAssemblerX86Common.h: derivative of original but constrained to 32 bit operations : void move(TrustedImmPtr imm, RegisterID dest)
MacroAssembler.h: added : Jump branchTestPtr(ResultCondition cond, AbsoluteAddress address, TrustedImm32 mask = TrustedImm32(-1))
MacroAssembler.h: added : void orPtr(TrustedImm32 imm, RegisterID src, RegisterID dest)
MacroAssembler.h: removed: void move(ImmPtr imm, RegisterID dest)

not applied:
MacroAssembler.h from 2.0.4 patch: void comparePtr(RelationalCondition cond, RegisterID left, TrustedImm32 right, RegisterID dest)
MacroAssembler.h from 2.0.4 patch: void comparePtr(RelationalCondition cond, RegisterID left, RegisterID right, RegisterID dest)
--

diff -urp webkitgtk-2.12.3.orig/Source/JavaScriptCore/assembler/AbstractMacroAssembler.h webkitgtk-2.12.3/Source/JavaScriptCore/assembler/AbstractMacroAssembler.h
--- webkitgtk-2.12.3.orig/Source/JavaScriptCore/assembler/AbstractMacroAssembler.h	2016-05-23 03:03:35.000000000 -0700
+++ webkitgtk-2.12.3/Source/JavaScriptCore/assembler/AbstractMacroAssembler.h	2017-05-31 11:06:00.134633901 -0700
@@ -299,7 +299,7 @@ public:
         {
         }
 
-#if !CPU(X86_64)
+#if !CPU(X86_64) || CPU(X32)
         explicit TrustedImm32(TrustedImmPtr ptr)
             : m_value(ptr.asIntptr())
         {
@@ -315,7 +315,7 @@ public:
             : TrustedImm32(value)
         {
         }
-#if !CPU(X86_64)
+#if !CPU(X86_64) || CPU(X32)
         explicit Imm32(TrustedImmPtr ptr)
             : TrustedImm32(ptr)
         {
@@ -339,7 +339,7 @@ public:
         {
         }
 
-#if CPU(X86_64) || CPU(ARM64)
+#if (CPU(X86_64) && !CPU(X32)) || CPU(ARM64)
         explicit TrustedImm64(TrustedImmPtr ptr)
             : m_value(ptr.asIntptr())
         {
@@ -355,7 +355,7 @@ public:
             : TrustedImm64(value)
         {
         }
-#if CPU(X86_64) || CPU(ARM64)
+#if (CPU(X86_64) && !CPU(X32)) || CPU(ARM64)
         explicit Imm64(TrustedImmPtr ptr)
             : TrustedImm64(ptr)
         {
diff -urp webkitgtk-2.12.3.orig/Source/JavaScriptCore/assembler/MacroAssembler.h webkitgtk-2.12.3/Source/JavaScriptCore/assembler/MacroAssembler.h
--- webkitgtk-2.12.3.orig/Source/JavaScriptCore/assembler/MacroAssembler.h	2016-05-23 03:03:35.000000000 -0700
+++ webkitgtk-2.12.3/Source/JavaScriptCore/assembler/MacroAssembler.h	2017-05-31 11:06:13.989165130 -0700
@@ -506,7 +506,7 @@ public:
     // Ptr methods
     // On 32-bit platforms (i.e. x86), these methods directly map onto their 32-bit equivalents.
     // FIXME: should this use a test for 32-bitness instead of this specific exception?
-#if !CPU(X86_64) && !CPU(ARM64)
+#if !CPU(X86_64) && !CPU(ARM64) || CPU(X32)
     void addPtr(Address src, RegisterID dest)
     {
         add32(src, dest);
@@ -602,6 +602,11 @@ public:
         or32(imm, dest);
     }
 
+    void orPtr(TrustedImm32 imm, RegisterID src, RegisterID dest)
+    {
+        or32(imm, src, dest);
+    }
+    
     void subPtr(RegisterID src, RegisterID dest)
     {
         sub32(src, dest);
@@ -653,11 +658,6 @@ public:
         return load32WithCompactAddressOffsetPatch(address, dest);
     }
 
-    void move(ImmPtr imm, RegisterID dest)
-    {
-        move(Imm32(imm.asTrustedImmPtr()), dest);
-    }
-
     void comparePtr(RelationalCondition cond, RegisterID left, TrustedImm32 right, RegisterID dest)
     {
         compare32(cond, left, right, dest);
@@ -688,11 +688,6 @@ public:
         store32(TrustedImm32(imm), address);
     }
     
-    void storePtr(ImmPtr imm, Address address)
-    {
-        store32(Imm32(imm.asTrustedImmPtr()), address);
-    }
-
     void storePtr(TrustedImmPtr imm, void* address)
     {
         store32(TrustedImm32(imm), address);
@@ -723,11 +718,6 @@ public:
         return branch32(cond, left, TrustedImm32(right));
     }
     
-    Jump branchPtr(RelationalCondition cond, RegisterID left, ImmPtr right)
-    {
-        return branch32(cond, left, Imm32(right.asTrustedImmPtr()));
-    }
-
     Jump branchPtr(RelationalCondition cond, RegisterID left, Address right)
     {
         return branch32(cond, left, right);
@@ -768,6 +758,11 @@ public:
         return branchTest32(cond, reg, mask);
     }
 
+    Jump branchTestPtr(ResultCondition cond, AbsoluteAddress address, TrustedImm32 mask = TrustedImm32(-1))
+    {
+        return branchTest32(cond, address, mask);
+    }
+
     Jump branchTestPtr(ResultCondition cond, Address address, TrustedImm32 mask = TrustedImm32(-1))
     {
         return branchTest32(cond, address, mask);
@@ -793,6 +788,28 @@ public:
         return MacroAssemblerBase::branchTest8(cond, Address(address.base, address.offset), mask);
     }
 
+#if !CPU(X32)
+    void move(ImmPtr imm, RegisterID dest)
+    {
+        move(Imm32(imm.asTrustedImmPtr()), dest);
+    }
+
+    void storePtr(ImmPtr imm, Address address)
+    {
+        store32(Imm32(imm.asTrustedImmPtr()), address);
+    }
+
+    Jump branchPtr(RelationalCondition cond, RegisterID left, ImmPtr right)
+    {
+        return branch32(cond, left, Imm32(right.asTrustedImmPtr()));
+    }
+#else
+    void rotateRightPtr(TrustedImm32 imm, RegisterID srcDst)
+    {
+        rotateRight32(imm, srcDst);
+    }
+#endif
+
 #else // !CPU(X86_64)
 
     void addPtr(RegisterID src, RegisterID dest)
@@ -1099,6 +1116,9 @@ public:
     {
         return branchSub64(cond, src1, src2, dest);
     }
+#endif // !CPU(X86_64) || CPU(X32)
+
+#if CPU(X86_64)
 
     using MacroAssemblerBase::and64;
     using MacroAssemblerBase::convertInt32ToDouble;
@@ -1152,10 +1172,12 @@ public:
         case 0xffff:
         case 0xffffff:
         case 0xffffffffL:
+#if !CPU(X32)
         case 0xffffffffffL:
         case 0xffffffffffffL:
         case 0xffffffffffffffL:
         case 0xffffffffffffffffL:
+#endif
             return false;
         default: {
             if (value <= 0xff)
@@ -1329,7 +1351,7 @@ public:
             store64(imm.asTrustedImm64(), dest);
     }
 
-#endif // !CPU(X86_64)
+#endif // CPU(X86_64)
 
 #if ENABLE(B3_JIT)
     // We should implement this the right way eventually, but for now, it's fine because it arises so
diff -urp webkitgtk-2.12.3.orig/Source/JavaScriptCore/assembler/MacroAssemblerX86Common.h webkitgtk-2.12.3/Source/JavaScriptCore/assembler/MacroAssemblerX86Common.h
--- webkitgtk-2.12.3.orig/Source/JavaScriptCore/assembler/MacroAssemblerX86Common.h	2016-05-23 03:03:35.000000000 -0700
+++ webkitgtk-2.12.3/Source/JavaScriptCore/assembler/MacroAssemblerX86Common.h	2017-05-31 11:06:32.006857487 -0700
@@ -1533,7 +1533,12 @@ public:
 
     void push(Address address)
     {
+#if CPU(X32)
+        load32(address, scratchRegister());
+        m_assembler.push_r(scratchRegister());
+#else
         m_assembler.push_m(address.offset, address.base);
+#endif
     }
 
     void push(TrustedImm32 imm)
@@ -1567,10 +1572,17 @@ public:
 
     void move(TrustedImmPtr imm, RegisterID dest)
     {
+#if CPU(X32)
+        if (!imm.m_value)
+            m_assembler.xorl_rr(dest, dest);
+        else
+            m_assembler.movl_i32r(imm.asIntptr(), dest);
+#else
         if (!imm.m_value)
             m_assembler.xorq_rr(dest, dest);
         else
             m_assembler.movq_i64r(imm.asIntptr(), dest);
+#endif
     }
 
     void move(TrustedImm64 imm, RegisterID dest)
@@ -1980,6 +1992,12 @@ public:
         return Jump(m_assembler.jCC(x86Condition(cond)));
     }
     
+    Jump branch32(RelationalCondition cond, AbsoluteAddress left, RegisterID right)
+    {
+        move(TrustedImmPtr(left.m_ptr), scratchRegister());
+        return branch32(cond, Address(scratchRegister()), right);
+    }
+
     Jump branch32(RelationalCondition cond, Address left, RegisterID right)
     {
         m_assembler.cmpl_rm(right, left.offset, left.base);
@@ -2091,7 +2109,12 @@ public:
     // Address is a memory location containing the address to jump to
     void jump(Address address)
     {
+#if CPU(X32)
+        load32(address, scratchRegister());
+        m_assembler.jmp_r(scratchRegister());
+#else
         m_assembler.jmp_m(address.offset, address.base);
+#endif
     }
 
 
@@ -2275,7 +2298,12 @@ public:
 
     void call(Address address)
     {
+#if CPU(X32)
+        load32(address, scratchRegister());
+        m_assembler.call(scratchRegister());
+#else
         m_assembler.call_m(address.offset, address.base);
+#endif
     }
 
     void ret()
diff -urp webkitgtk-2.12.3.orig/Source/JavaScriptCore/assembler/MacroAssemblerX86_64.h webkitgtk-2.12.3/Source/JavaScriptCore/assembler/MacroAssemblerX86_64.h
--- webkitgtk-2.12.3.orig/Source/JavaScriptCore/assembler/MacroAssemblerX86_64.h	2016-05-23 03:03:35.000000000 -0700
+++ webkitgtk-2.12.3/Source/JavaScriptCore/assembler/MacroAssemblerX86_64.h	2017-05-31 11:06:32.006857487 -0700
@@ -38,10 +38,15 @@ namespace JSC {
 
 class MacroAssemblerX86_64 : public MacroAssemblerX86Common {
 public:
+#if CPU(X32)
+    static const Scale ScalePtr = TimesFour;
+#else
     static const Scale ScalePtr = TimesEight;
+#endif
 
     using MacroAssemblerX86Common::add32;
     using MacroAssemblerX86Common::and32;
+    using MacroAssemblerX86Common::branch32;
     using MacroAssemblerX86Common::branchAdd32;
     using MacroAssemblerX86Common::or32;
     using MacroAssemblerX86Common::sub32;
@@ -119,6 +124,11 @@ public:
         m_assembler.cvtsi2sd_rr(scratchRegister(), dest);
     }
 
+    void rotateRight32(TrustedImm32 imm, RegisterID srcDst)
+    {
+        m_assembler.rorl_i8r(imm.m_value, srcDst);
+    }
+
     void store32(TrustedImm32 imm, void* address)
     {
         move(TrustedImmPtr(address), scratchRegister());
@@ -135,6 +145,44 @@ public:
         }
     }
     
+    //void store32(RegisterID src, void* address)
+    //{
+    //    if (src == X86Registers::eax)
+    //        m_assembler.movl_EAXm(address);
+    //    else {
+    //        move(TrustedImmPtr(address), scratchRegister());
+    //        store32(src, scratchRegister());
+    //    }
+    //}
+    
+    Jump branch32(RelationalCondition cond, AbsoluteAddress left, RegisterID right)
+    {
+        move(TrustedImmPtr(left.m_ptr), scratchRegister());
+        return branch32(cond, Address(scratchRegister()), right);
+    }
+
+    Jump branch32(RelationalCondition cond, AbsoluteAddress left, TrustedImm32 right)
+    {
+        move(TrustedImmPtr(left.m_ptr), scratchRegister());
+        return branch32(cond, left, right);
+    }
+
+    Jump branch32(RelationalCondition cond, RegisterID left, RegisterID right)
+    {
+        m_assembler.cmpl_rr(right, left);
+        return Jump(m_assembler.jCC(x86Condition(cond)));
+    }
+
+    Jump branch32(RelationalCondition cond, RegisterID left, TrustedImm32 right)
+    {
+        if (!right.m_value) {
+            if (auto resultCondition = commuteCompareToZeroIntoTest(cond))
+                return branchTest32(*resultCondition, left, left);
+        }
+        m_assembler.cmpl_ir(right.m_value, left);
+        return Jump(m_assembler.jCC(x86Condition(cond)));
+    }
+
     void store8(TrustedImm32 imm, void* address)
     {
         move(TrustedImmPtr(address), scratchRegister());
@@ -1147,34 +1195,54 @@ public:
     ConvertibleLoadLabel convertibleLoadPtr(Address address, RegisterID dest)
     {
         ConvertibleLoadLabel result = ConvertibleLoadLabel(this);
+#if CPU(X32)
+        m_assembler.movl_mr(address.offset, address.base, dest);
+#else
         m_assembler.movq_mr(address.offset, address.base, dest);
+#endif
         return result;
     }
 
     DataLabelPtr moveWithPatch(TrustedImmPtr initialValue, RegisterID dest)
     {
         padBeforePatch();
+#if CPU(X32)
+        m_assembler.movl_i32r(initialValue.asIntptr(), dest);
+#else
         m_assembler.movq_i64r(initialValue.asIntptr(), dest);
+#endif
         return DataLabelPtr(this);
     }
 
     DataLabelPtr moveWithPatch(TrustedImm32 initialValue, RegisterID dest)
     {
         padBeforePatch();
+#if CPU(X32)
+        m_assembler.movl_i32r(initialValue.m_value, dest);
+#else
         m_assembler.movq_i64r(initialValue.m_value, dest);
+#endif
         return DataLabelPtr(this);
     }
 
     Jump branchPtrWithPatch(RelationalCondition cond, RegisterID left, DataLabelPtr& dataLabel, TrustedImmPtr initialRightValue = TrustedImmPtr(0))
     {
         dataLabel = moveWithPatch(initialRightValue, scratchRegister());
+#if CPU(X32)
+        return branch32(cond, left, scratchRegister());
+#else
         return branch64(cond, left, scratchRegister());
+#endif
     }
 
     Jump branchPtrWithPatch(RelationalCondition cond, Address left, DataLabelPtr& dataLabel, TrustedImmPtr initialRightValue = TrustedImmPtr(0))
     {
         dataLabel = moveWithPatch(initialRightValue, scratchRegister());
+#if CPU(X32)
+        return branch32(cond, left, scratchRegister());
+#else
         return branch64(cond, left, scratchRegister());
+#endif
     }
 
     Jump branch32WithPatch(RelationalCondition cond, Address left, DataLabel32& dataLabel, TrustedImm32 initialRightValue = TrustedImm32(0))
@@ -1188,7 +1256,11 @@ public:
     DataLabelPtr storePtrWithPatch(TrustedImmPtr initialValue, ImplicitAddress address)
     {
         DataLabelPtr label = moveWithPatch(initialValue, scratchRegister());
+#if CPU(X32)
+        store32(scratchRegister(), address);
+#else
         store64(scratchRegister(), address);
+#endif
         return label;
     }
 
@@ -1223,6 +1295,48 @@ public:
         return MacroAssemblerX86Common::branchTest8(cond, Address(scratchRegister()), mask);
     }
 
+    Jump branchTest32(ResultCondition cond, RegisterID reg, RegisterID mask)
+    {
+        m_assembler.testl_rr(reg, mask);
+        return Jump(m_assembler.jCC(x86Condition(cond)));
+    }
+
+    Jump branchTest32(ResultCondition cond, AbsoluteAddress address, TrustedImm32 mask = TrustedImm32(-1))
+    {
+        load32(address.m_ptr, scratchRegister());
+        return branchTest32(cond, scratchRegister(), mask);
+    }
+
+    Jump branchTest32(ResultCondition cond, Address address, TrustedImm32 mask = TrustedImm32(-1))
+    {
+        if (mask.m_value == -1)
+            m_assembler.cmpl_im(0, address.offset, address.base);
+        else
+            m_assembler.testl_i32m(mask.m_value, address.offset, address.base);
+        return Jump(m_assembler.jCC(x86Condition(cond)));
+    }
+
+    Jump branchTest32(ResultCondition cond, BaseIndex address, TrustedImm32 mask = TrustedImm32(-1))
+    {
+        if (mask.m_value == -1)
+            m_assembler.cmpl_im(0, address.offset, address.base, address.index, address.scale);
+        else
+            m_assembler.testl_i32m(mask.m_value, address.offset, address.base, address.index, address.scale);
+        return Jump(m_assembler.jCC(x86Condition(cond)));
+    }
+
+    Jump branchTest32(ResultCondition cond, RegisterID reg, TrustedImm32 mask = TrustedImm32(-1))
+    {
+        // if we are only interested in the low seven bits, this can be tested with a testb
+        if (mask.m_value == -1)
+            m_assembler.testl_rr(reg, reg);
+        else if ((mask.m_value & ~0x7f) == 0)
+            m_assembler.testb_i8r(mask.m_value, reg);
+        else
+            m_assembler.testl_i32r(mask.m_value, reg);
+        return Jump(m_assembler.jCC(x86Condition(cond)));
+    }
+
     void convertInt64ToDouble(RegisterID src, FPRegisterID dest)
     {
         m_assembler.cvtsi2sdq_rr(src, dest);
@@ -1248,7 +1362,7 @@ public:
     {
         const int rexBytes = 1;
         const int opcodeBytes = 1;
-        const int immediateBytes = 8;
+        const int immediateBytes = sizeof(void*);
         const int totalBytes = rexBytes + opcodeBytes + immediateBytes;
         ASSERT(totalBytes >= maxJumpReplacementSize());
         return label.labelAtOffset(-totalBytes);
@@ -1276,7 +1390,11 @@ public:
     
     static void revertJumpReplacementToPatchableBranchPtrWithPatch(CodeLocationLabel instructionStart, Address, void* initialValue)
     {
-        X86Assembler::revertJumpTo_movq_i64r(instructionStart.executableAddress(), reinterpret_cast<intptr_t>(initialValue), s_scratchRegister);
+#if CPU(X32)
+        X86Assembler::revertJumpTo_movl_i32r(instructionStart.executableAddress(), reinterpret_cast<uintptr_t>(initialValue), s_scratchRegister);
+#else
+        X86Assembler::revertJumpTo_movq_i64r(instructionStart.executableAddress(), reinterpret_cast<uintptr_t>(initialValue), s_scratchRegister);
+#endif
     }
 
     static void revertJumpReplacementToPatchableBranch32WithPatch(CodeLocationLabel instructionStart, Address, int32_t initialValue)
@@ -1286,7 +1404,11 @@ public:
 
     static void revertJumpReplacementToBranchPtrWithPatch(CodeLocationLabel instructionStart, RegisterID, void* initialValue)
     {
-        X86Assembler::revertJumpTo_movq_i64r(instructionStart.executableAddress(), reinterpret_cast<intptr_t>(initialValue), s_scratchRegister);
+#if CPU(X32)
+        X86Assembler::revertJumpTo_movl_i32r(instructionStart.executableAddress(), reinterpret_cast<uintptr_t>(initialValue), s_scratchRegister);
+#else
+        X86Assembler::revertJumpTo_movq_i64r(instructionStart.executableAddress(), reinterpret_cast<uintptr_t>(initialValue), s_scratchRegister);
+#endif
     }
 
     static void repatchCall(CodeLocationCall call, CodeLocationLabel destination)
diff -urp webkitgtk-2.12.3.orig/Source/JavaScriptCore/assembler/MaxFrameExtentForSlowPathCall.h webkitgtk-2.12.3/Source/JavaScriptCore/assembler/MaxFrameExtentForSlowPathCall.h
--- webkitgtk-2.12.3.orig/Source/JavaScriptCore/assembler/MaxFrameExtentForSlowPathCall.h	2016-04-10 23:18:43.000000000 -0700
+++ webkitgtk-2.12.3/Source/JavaScriptCore/assembler/MaxFrameExtentForSlowPathCall.h	2017-05-31 11:06:06.996897542 -0700
@@ -44,7 +44,7 @@ static const size_t maxFrameExtentForSlo
 // 4 args in registers, but stack space needs to be allocated for all args.
 static const size_t maxFrameExtentForSlowPathCall = 64;
 
-#elif CPU(X86_64)
+#elif CPU(X86_64) || CPU(X32)
 // All args in registers.
 static const size_t maxFrameExtentForSlowPathCall = 0;
 
diff -urp webkitgtk-2.12.3.orig/Source/JavaScriptCore/assembler/X86Assembler.h webkitgtk-2.12.3/Source/JavaScriptCore/assembler/X86Assembler.h
--- webkitgtk-2.12.3.orig/Source/JavaScriptCore/assembler/X86Assembler.h	2016-05-23 03:03:35.000000000 -0700
+++ webkitgtk-2.12.3/Source/JavaScriptCore/assembler/X86Assembler.h	2017-05-31 11:06:00.138634053 -0700
@@ -1015,6 +1015,16 @@ public:
     {
         m_formatter.twoByteOp64(OP2_BSR, dst, base, offset);
     }
+
+    void rorl_i8r(int imm, RegisterID dst)
+    {
+        if (imm == 1)
+            m_formatter.oneByteOp(OP_GROUP2_Ev1, GROUP2_OP_ROR, dst);
+        else {
+            m_formatter.oneByteOp(OP_GROUP2_EvIb, GROUP2_OP_ROR, dst);
+            m_formatter.immediate8(imm);
+        }
+    }
 #endif
 
     void sarl_i8r(int imm, RegisterID dst)
@@ -1402,6 +1412,11 @@ public:
         m_formatter.oneByteOp64(OP_TEST_EvGv, src, base, offset);
     }
 
+    void testl_rm(RegisterID src, int offset, RegisterID base)
+    {
+        m_formatter.oneByteOp(OP_TEST_EvGv, src, base, offset);
+    }
+
     void testq_i32r(int imm, RegisterID dst)
     {
         if (dst == X86Registers::eax)
@@ -1554,7 +1569,7 @@ public:
     {
         m_formatter.oneByteOp(OP_MOV_EAXOv);
 #if CPU(X86_64)
-        m_formatter.immediate64(reinterpret_cast<int64_t>(addr));
+        m_formatter.immediate64(reinterpret_cast<uintptr_t>(addr));
 #else
         m_formatter.immediate32(reinterpret_cast<int>(addr));
 #endif
@@ -1657,7 +1672,7 @@ public:
     {
         m_formatter.oneByteOp(OP_MOV_OvEAX);
 #if CPU(X86_64)
-        m_formatter.immediate64(reinterpret_cast<int64_t>(addr));
+        m_formatter.immediate64(reinterpret_cast<uintptr_t>(addr));
 #else
         m_formatter.immediate32(reinterpret_cast<int>(addr));
 #endif
@@ -1687,13 +1702,13 @@ public:
     void movq_mEAX(const void* addr)
     {
         m_formatter.oneByteOp64(OP_MOV_EAXOv);
-        m_formatter.immediate64(reinterpret_cast<int64_t>(addr));
+        m_formatter.immediate64(reinterpret_cast<uintptr_t>(addr));
     }
 
     void movq_EAXm(const void* addr)
     {
         m_formatter.oneByteOp64(OP_MOV_OvEAX);
-        m_formatter.immediate64(reinterpret_cast<int64_t>(addr));
+        m_formatter.immediate64(reinterpret_cast<uintptr_t>(addr));
     }
 
     void movq_mr(int offset, RegisterID base, RegisterID dst)
diff -urp webkitgtk-2.12.3.orig/Source/JavaScriptCore/dfg/DFGEdge.h webkitgtk-2.12.3/Source/JavaScriptCore/dfg/DFGEdge.h
--- webkitgtk-2.12.3.orig/Source/JavaScriptCore/dfg/DFGEdge.h	2016-04-10 23:18:43.000000000 -0700
+++ webkitgtk-2.12.3/Source/JavaScriptCore/dfg/DFGEdge.h	2017-05-31 11:06:32.007857525 -0700
@@ -38,7 +38,7 @@ class AdjacencyList;
 class Edge {
 public:
     explicit Edge(Node* node = 0, UseKind useKind = UntypedUse, ProofStatus proofStatus = NeedsCheck, KillStatus killStatus = DoesNotKill)
-#if USE(JSVALUE64)
+#if USE(JSVALUE64) && !CPU(X32)
         : m_encodedWord(makeWord(node, useKind, proofStatus, killStatus))
 #else
         : m_node(node)
@@ -47,7 +47,7 @@ public:
     {
     }
     
-#if USE(JSVALUE64)
+#if USE(JSVALUE64) && !CPU(X32)
     Node* node() const { return bitwise_cast<Node*>(m_encodedWord >> shift()); }
 #else
     Node* node() const { return m_node; }
@@ -58,7 +58,7 @@ public:
     
     void setNode(Node* node)
     {
-#if USE(JSVALUE64)
+#if USE(JSVALUE64) && !CPU(X32)
         m_encodedWord = makeWord(node, useKind(), proofStatus(), killStatus());
 #else
         m_node = node;
@@ -67,7 +67,7 @@ public:
     
     UseKind useKindUnchecked() const
     {
-#if USE(JSVALUE64)
+#if USE(JSVALUE64) && !CPU(X32)
         unsigned masked = m_encodedWord & (((1 << shift()) - 1));
         unsigned shifted = masked >> 2;
 #else
@@ -86,7 +86,7 @@ public:
     void setUseKind(UseKind useKind)
     {
         ASSERT(node());
-#if USE(JSVALUE64)
+#if USE(JSVALUE64) && !CPU(X32)
         m_encodedWord = makeWord(node(), useKind, proofStatus(), killStatus());
 #else
         m_encodedWord = makeWord(useKind, proofStatus(), killStatus());
@@ -105,7 +105,7 @@ public:
     void setProofStatus(ProofStatus proofStatus)
     {
         ASSERT(node());
-#if USE(JSVALUE64)
+#if USE(JSVALUE64) && !CPU(X32)
         m_encodedWord = makeWord(node(), useKind(), proofStatus, killStatus());
 #else
         m_encodedWord = makeWord(useKind(), proofStatus, killStatus());
@@ -137,7 +137,7 @@ public:
     void setKillStatus(KillStatus killStatus)
     {
         ASSERT(node());
-#if USE(JSVALUE64)
+#if USE(JSVALUE64) && !CPU(X32)
         m_encodedWord = makeWord(node(), useKind(), proofStatus(), killStatus);
 #else
         m_encodedWord = makeWord(useKind(), proofStatus(), killStatus);
@@ -151,7 +151,7 @@ public:
     Edge sanitized() const
     {
         Edge result = *this;
-#if USE(JSVALUE64)
+#if USE(JSVALUE64) && !CPU(X32)
         result.m_encodedWord = makeWord(node(), useKindUnchecked(), NeedsCheck, DoesNotKill);
 #else
         result.m_encodedWord = makeWord(useKindUnchecked(), NeedsCheck, DoesNotKill);
@@ -164,7 +164,7 @@ public:
     
     bool operator==(Edge other) const
     {
-#if USE(JSVALUE64)
+#if USE(JSVALUE64) && !CPU(X32)
         return m_encodedWord == other.m_encodedWord;
 #else
         return m_node == other.m_node && m_encodedWord == other.m_encodedWord;
@@ -179,7 +179,7 @@ public:
     
     unsigned hash() const
     {
-#if USE(JSVALUE64)
+#if USE(JSVALUE64) && !CPU(X32)
         return IntHash<uintptr_t>::hash(m_encodedWord);
 #else
         return PtrHash<Node*>::hash(m_node) + m_encodedWord;
@@ -189,7 +189,7 @@ public:
 private:
     friend class AdjacencyList;
     
-#if USE(JSVALUE64)
+#if USE(JSVALUE64) && !CPU(X32)
     static uint32_t shift() { return 7; }
     
     static uintptr_t makeWord(Node* node, UseKind useKind, ProofStatus proofStatus, KillStatus killStatus)
diff -urp webkitgtk-2.12.3.orig/Source/JavaScriptCore/dfg/DFGNode.h webkitgtk-2.12.3/Source/JavaScriptCore/dfg/DFGNode.h
--- webkitgtk-2.12.3.orig/Source/JavaScriptCore/dfg/DFGNode.h	2016-05-23 03:03:36.000000000 -0700
+++ webkitgtk-2.12.3/Source/JavaScriptCore/dfg/DFGNode.h	2017-05-31 11:06:32.008857563 -0700
@@ -226,7 +226,7 @@ struct OpInfo {
     OpInfo() : m_value(0) { }
     explicit OpInfo(int32_t value) : m_value(static_cast<uintptr_t>(value)) { }
     explicit OpInfo(uint32_t value) : m_value(static_cast<uintptr_t>(value)) { }
-#if OS(DARWIN) || USE(JSVALUE64)
+#if !CPU(X32) && (OS(DARWIN) || (CPU(X86_64) && !CPU(X32)))
     explicit OpInfo(size_t value) : m_value(static_cast<uintptr_t>(value)) { }
 #endif
     explicit OpInfo(void* value) : m_value(reinterpret_cast<uintptr_t>(value)) { }
diff -urp webkitgtk-2.12.3.orig/Source/JavaScriptCore/dfg/DFGSpeculativeJIT64.cpp webkitgtk-2.12.3/Source/JavaScriptCore/dfg/DFGSpeculativeJIT64.cpp
--- webkitgtk-2.12.3.orig/Source/JavaScriptCore/dfg/DFGSpeculativeJIT64.cpp	2016-05-23 03:03:36.000000000 -0700
+++ webkitgtk-2.12.3/Source/JavaScriptCore/dfg/DFGSpeculativeJIT64.cpp	2017-05-31 13:41:07.794735202 -0700
@@ -831,6 +831,10 @@ void SpeculativeJIT::emitCall(Node* node
     JITCompiler::DataLabelPtr targetToCheck;
     JITCompiler::Jump slowPath = m_jit.branchPtrWithPatch(MacroAssembler::NotEqual, calleeGPR, targetToCheck, MacroAssembler::TrustedImmPtr(0));
 
+#if CPU(X32)
+    slowPath.append(m_jit.branchTest64(MacroAssembler::NonZero, calleeGPR, GPRInfo::tagMaskRegister));
+#endif
+
     if (isTail) {
         if (node->op() == TailCall) {
             callLinkInfo->setFrameShuffleData(shuffleData);
diff -urp webkitgtk-2.12.3.orig/Source/JavaScriptCore/jit/ExecutableAllocator.h webkitgtk-2.12.3/Source/JavaScriptCore/jit/ExecutableAllocator.h
--- webkitgtk-2.12.3.orig/Source/JavaScriptCore/jit/ExecutableAllocator.h	2016-05-23 03:03:36.000000000 -0700
+++ webkitgtk-2.12.3/Source/JavaScriptCore/jit/ExecutableAllocator.h	2017-05-31 11:06:00.141634167 -0700
@@ -78,7 +78,7 @@ class DemandExecutableAllocator;
 static const size_t fixedExecutableMemoryPoolSize = 16 * 1024 * 1024;
 #elif CPU(ARM64)
 static const size_t fixedExecutableMemoryPoolSize = 32 * 1024 * 1024;
-#elif CPU(X86_64)
+#elif CPU(X86_64) && !CPU(X32)
 static const size_t fixedExecutableMemoryPoolSize = 1024 * 1024 * 1024;
 #else
 static const size_t fixedExecutableMemoryPoolSize = 32 * 1024 * 1024;
diff -urp webkitgtk-2.12.3.orig/Source/JavaScriptCore/jit/JITCall.cpp webkitgtk-2.12.3/Source/JavaScriptCore/jit/JITCall.cpp
--- webkitgtk-2.12.3.orig/Source/JavaScriptCore/jit/JITCall.cpp	2016-05-23 03:03:36.000000000 -0700
+++ webkitgtk-2.12.3/Source/JavaScriptCore/jit/JITCall.cpp	2017-05-31 13:36:53.779960863 -0700
@@ -110,6 +110,10 @@ void JIT::compileCallEvalSlowCase(Instru
     info->setUpCall(CallLinkInfo::Call, CodeOrigin(m_bytecodeOffset), regT0);
 
     linkSlowCase(iter);
+#if CPU(X32)
+    linkSlowCase(iter);
+#endif
+
     int registerOffset = -instruction[4].u.operand;
 
     addPtr(TrustedImm32(registerOffset * sizeof(Register) + sizeof(CallerFrameAndPC)), callFrameRegister, stackPointerRegister);
@@ -185,6 +189,11 @@ void JIT::compileOpCall(OpcodeID opcodeI
     Jump slowCase = branchPtrWithPatch(NotEqual, regT0, addressOfLinkedFunctionCheck, TrustedImmPtr(0));
     addSlowCase(slowCase);
 
+#if CPU(X32)
+    // The above branchPtr doesn't catch the case where the callee isn't a cell.
+    addSlowCase(branchTest64(NonZero, regT0, tagMaskRegister));
+#endif
+
     ASSERT(m_callCompilationInfo.size() == callLinkInfoIndex);
     info->setUpCall(CallLinkInfo::callTypeFor(opcodeID), CodeOrigin(m_bytecodeOffset), regT0);
     m_callCompilationInfo.append(CallCompilationInfo());
diff -urp webkitgtk-2.12.3.orig/Source/JavaScriptCore/jit/JITOperations.cpp webkitgtk-2.12.3/Source/JavaScriptCore/jit/JITOperations.cpp
--- webkitgtk-2.12.3.orig/Source/JavaScriptCore/jit/JITOperations.cpp	2016-05-23 03:03:36.000000000 -0700
+++ webkitgtk-2.12.3/Source/JavaScriptCore/jit/JITOperations.cpp	2017-05-31 11:06:00.142634205 -0700
@@ -2123,6 +2123,7 @@ extern "C" EncodedJSValue HOST_CALL_RETU
 
 #if COMPILER(GCC_OR_CLANG) && CPU(X86_64)
 asm (
+".text" "\n" \
 ".globl " SYMBOL_STRING(getHostCallReturnValue) "\n"
 HIDE_SYMBOL(getHostCallReturnValue) "\n"
 SYMBOL_STRING(getHostCallReturnValue) ":" "\n"
diff -urp webkitgtk-2.12.3.orig/Source/JavaScriptCore/runtime/BasicBlockLocation.cpp webkitgtk-2.12.3/Source/JavaScriptCore/runtime/BasicBlockLocation.cpp
--- webkitgtk-2.12.3.orig/Source/JavaScriptCore/runtime/BasicBlockLocation.cpp	2016-04-10 23:18:43.000000000 -0700
+++ webkitgtk-2.12.3/Source/JavaScriptCore/runtime/BasicBlockLocation.cpp	2017-05-31 11:06:11.669076675 -0700
@@ -82,8 +82,13 @@ void BasicBlockLocation::dumpData() cons
 #if USE(JSVALUE64)
 void BasicBlockLocation::emitExecuteCode(CCallHelpers& jit) const
 {
+#if CPU(X32)
+    static_assert(sizeof(size_t) == 4, "Assuming size_t is 32 bits on 64 bit platforms.");
+    jit.add32(CCallHelpers::TrustedImm32(1), CCallHelpers::AbsoluteAddress(&m_executionCount));
+#else
     static_assert(sizeof(size_t) == 8, "Assuming size_t is 64 bits on 64 bit platforms.");
     jit.add64(CCallHelpers::TrustedImm32(1), CCallHelpers::AbsoluteAddress(&m_executionCount));
+#endif
 }
 #else
 void BasicBlockLocation::emitExecuteCode(CCallHelpers& jit, MacroAssembler::RegisterID scratch) const
diff -urp webkitgtk-2.12.3.orig/Source/JavaScriptCore/runtime/MatchResult.h webkitgtk-2.12.3/Source/JavaScriptCore/runtime/MatchResult.h
--- webkitgtk-2.12.3.orig/Source/JavaScriptCore/runtime/MatchResult.h	2016-05-23 03:03:36.000000000 -0700
+++ webkitgtk-2.12.3/Source/JavaScriptCore/runtime/MatchResult.h	2017-05-31 11:06:00.143634243 -0700
@@ -64,8 +64,13 @@ struct MatchResult {
         return start == end;
     }
 
+#if CPU(X32)
+    uint64_t start;
+    uint64_t end;
+#else
     size_t start;
     size_t end;
+#endif
 };
 
 #endif
diff -urp webkitgtk-2.12.3.orig/Source/WTF/wtf/Platform.h webkitgtk-2.12.3/Source/WTF/wtf/Platform.h
--- webkitgtk-2.12.3.orig/Source/WTF/wtf/Platform.h	2016-05-23 03:03:36.000000000 -0700
+++ webkitgtk-2.12.3/Source/WTF/wtf/Platform.h	2017-05-31 11:06:00.143634243 -0700
@@ -168,6 +168,9 @@
 #if   defined(__x86_64__) \
     || defined(_M_X64)
 #define WTF_CPU_X86_64 1
+#if defined(__ILP32__)
+#define WTF_CPU_X32 1
+#endif
 #endif
 
 /* CPU(ARM64) - Apple */
